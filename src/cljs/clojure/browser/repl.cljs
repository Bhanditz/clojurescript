;;  Copyright (c) Rich Hickey. All rights reserved.
;;  The use and distribution terms for this software are covered by the
;;  Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)
;;  which can be found in the file epl-v10.html at the root of this distribution.
;;  By using this software in any fashion, you are agreeing to be bound by
;;  the terms of this license.
;;  You must not remove this notice, or any other, from this software.

(ns ^{:doc "Receive - Eval - Print - Loop

  Receive a block of JS (presumably generated by a ClojureScript compiler)
  Evaluate it naively
  Print the result of evaluation to a string
  Send the resulting string back to the server Loop!"

      :author "Bobby Calderwood and Alex Redington"}
  clojure.browser.repl
  (:require [cljs.reader :as reader]
            [clojure.browser.net   :as net]
            [clojure.browser.event :as event]))

(def xpc-connection (atom nil))
(def ^{:doc "A unique identifier for this REPL client."}
  client-id (atom nil))

(defn set-client-id
  "Accepts a unique identifier for this client and puts that value in
  the client-id atom on both sides of the cross-page channel.

  The value of client-id will be included in all messages sent back to
  the REPL. See wrap-message. This can be used for keeping track of
  multiple browsers connected to the same REPL."
  [id]
  (if-let [conn @xpc-connection]
    (do (reset! client-id id)
        (net/transmit conn :client-id (pr-str id))
        true)
    false))

(defn repl-print [data]
  (if-let [conn @xpc-connection]
    (net/transmit conn :print (pr-str data))))

(defn evaluate-javascript
  "Process a single block of JavaScript received from the server"
  [conn block]
  (let [result (try {:status :success :value (str (js* "eval(~{block})"))}
                    (catch js/Error e
                      {:status :exception :value (pr-str e)
                       :stacktrace (if (.hasOwnProperty e "stack")
                                     (.stack e)
                                     "No stacktrace available.")}))]
    (pr-str result)))

(defn send-result [connection url data]
  (net/transmit connection url "POST" data nil 0))

(defn send-print
  "Send data to be printed in the REPL. If there is an error, try again
  up to 10 times."
  ([url data]
     (send-print url data 0))
  ([url data n]
     (let [conn (net/xhr-connection)]
       (event/listen conn :error
                     (fn [_]
                       (if (< n 10)
                         (send-print url data (inc n))
                         (.log js/console (str "Could not send " data " after " n " attempts.")))))
       (net/transmit conn url "POST" data nil 0))))

(def order (atom 0))
(def form-id (atom nil))

(defn wrap-message
  "Accepts a type keyword and data and returns a serialized map with
  additional, REPL specific, information.

  The order of the result and the client-id are added to the
  map. This function runs in the inner-frame of the cross-page
  channel."
  [t data]
  (pr-str {:form-id @form-id
           :client-id @client-id
           :type t
           :content data
           :order (swap! order inc)}))

(defn start-evaluator
  "Start the REPL server connection."
  [url]
  (if-let [repl-connection (net/xpc-connection)]
    (let [connection (net/xhr-connection)]
      (event/listen connection
                    :success
                    (fn [e]
                      (net/transmit
                       repl-connection
                       :evaluate-javascript
                       (let [{:keys [id js]} (reader/read-string (.getResponseText e/currentTarget ()))]
                         (reset! form-id id)
                         js))))

      (net/register-service repl-connection
                            :send-result
                            (fn [data]
                              (send-result connection url (wrap-message :result data))))

      (net/register-service repl-connection
                            :print
                            (fn [data]
                              (send-print url (wrap-message :print data))))

      ;; Evaluating set-client-id in the host page will use the
      ;; :client-id service to send the client-id from the host page
      ;; to the inner-frame. It is required in the inner-frame so that
      ;; it can be sent back to the REPL with each return value.
      (net/register-service repl-connection
                            :client-id
                            (fn [data]
                              (reset! client-id (js/parseInt data))))
      
      (net/connect repl-connection
                   (constantly nil))

      (js/setTimeout #(send-result connection url (wrap-message :ready "ready")) 50))
    (js/alert "No 'xpc' param provided to child iframe.")))

(defn connect
  "Connects to a REPL server from an HTML document. After the
  connection is made, the REPL will evaluate forms in the context of
  the document that called this function."
  [repl-server-url]
  (let [repl-connection (net/xpc-connection
                         {:peer_uri repl-server-url})]
    (swap! xpc-connection (constantly repl-connection))
    (net/register-service repl-connection
                          :evaluate-javascript
                          (fn [js]
                            (net/transmit
                             repl-connection
                             :send-result
                             (evaluate-javascript repl-connection js))))
    (net/connect repl-connection
                 (constantly nil)
                 (fn [iframe]
                   (set! iframe.style.display
                         "none")))))
